<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>NOTION API HUB — 테스트 페이지</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
    :root{
      --gap:12px;
      --radius:10px;
      --border:#e5e7eb;
      --muted:#6b7280;
      /* 💚 메인 포인트 색상: 진한 녹색 */
      --main-color: #14532D; 
      /* 🟢 테이블 하이라이트 색상: 밝은 녹색 */
      --table-header: #D1FAE5;
      --table-text: #14532D;
      
      /* 🛠️ 기본 카드 너비 (선택 정보) */
      --base-max-width: 700px;

      /* 📌 지도 핀 색상 (기존 유지) */
      --pin-reg:   #2563eb; 
      --pin-search:#ef4444;
    }
    
    body{
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Segoe UI Emoji,Segoe UI Symbol,sans-serif;
      margin: 0; 
      padding: 24px 0;
      background: #fafafa;
      color: #111;
      display: flex; 
      flex-direction: column;
      align-items: center; 
    }
    
    h1{font-size:20px;margin:0 0 16px; padding: 0 16px; width: min(100%, var(--base-max-width));} 
    h3{ color: var(--main-color); margin-top:18px; font-weight:700; } 

    .card{
      background:#fff;
      border:1px solid var(--border);
      border-radius:var(--radius);
      padding:16px; 
      margin-bottom:16px;
      width: min(100% - 32px, var(--base-max-width)); 
      box-sizing: border-box; 
    }
    
    .card.expanded {
        width: min(100% - 32px, calc(var(--base-max-width) * 1.5));
    }
    
    /* 🛠️ 항목명(1fr)과 입력칸(3fr) 너비 유지 */
    .row{display:grid;grid-template-columns:1fr 3fr;gap:var(--gap);align-items:center;margin-bottom:10px}
    /* 🛠️ region-map-row는 지도열기 버튼을 안에 넣으므로, 일반 row와 동일하게 1fr 3fr 구조로 되돌립니다. */
    .row.region-map-row { grid-template-columns: 1fr 3fr; } 
    .row:last-child { margin-bottom: 0; }
    
    /* 🛠️ 드롭다운 목록이 부모 요소(.combo) 너비를 초과하지 않도록 수정 */
    .combo{position:relative}
    /* 🛠️ 콤보박스 입력 필드의 오른쪽 패딩을 늘려 버튼 공간 확보 */
    .combo input{width:100%;padding:10px 12px 10px 12px;border:1px solid var(--border);border-radius:8px;outline:none}
    
    /* 🛠️ 지역 콤보박스에만 오른쪽 패딩을 버튼 크기만큼 추가합니다. */
    #regionCombo input {
        padding-right: calc( (var(--gap) * 0.7) + 30px); /* 패딩: 30px, 버튼 너비: 약 70px, 총 100px. */
    }

    .combo .list{
      position:absolute;
      z-index:10;
      left:0;
      max-width: 100%;
      max-height:220px;
      overflow:auto;
      background:#fff;
      border:1px solid var(--border);
      border-radius:8px;
      margin-top:6px;
      display:none;
    }
    .combo.open .list{display:block}
    
    .item{padding:8px 10px;cursor:pointer}
    .item:hover{background:#f3f4f6}
    .tag{display:inline-flex;gap:6px;align-items:center;background:#eef2ff;border:1px solid #dbeafe;border-radius:999px;padding:4px 8px;margin-right:6px;margin-top:6px}
    .muted{color:var(--muted)}

    /* 🛠️ '지도 열기' 버튼 컨테이너 스타일 제거 (더 이상 별도의 그리드 셀이 아님) */
    /* .row.region-map-row > div:last-child { ... } 제거 */

    /* 💚 버튼 스타일 수정: 진한 녹색 적용 */
    button{
      border-radius:8px;
      border:1px solid var(--main-color);
      background:var(--main-color);
      color:#fff;
      cursor:pointer; 
      transition: background-color 0.15s, border-color 0.15s;
      width: fit-content; 
      white-space: nowrap; 
    }
    button:hover:not(:disabled){ background: #228b22; border-color: #228b22; }
    button:disabled{opacity:.6;cursor:not-allowed}
    
    /* 🛠️ 지도 열기 버튼 특수 스타일 (지역 콤보박스 안에 위치) */
    #btnToggleMap {
        position: absolute;
        /* 🛠️ 너비 70% 축소: 약 70px로 설정 */
        width: 70px; 
        right: 4px; /* 오른쪽에서 살짝 띄우기 */
        top: 50%;
        transform: translateY(-50%);
        padding: 6px 4px; /* 버튼 패딩 조정 */
        font-size: 13px; /* 폰트 크기 조정 */
        z-index: 15; /* 드롭다운 목록 위, 입력필드 위에 보이도록 z-index 설정 */
    }

    table{width:100%;border-collapse:collapse;margin-top:10px}
    th,td{border:1px solid var(--border);padding:8px;text-align:left; vertical-align: top;}
    th{background:var(--table-header); color:var(--table-text); font-weight:700;}
    table thead th:first-child,
    table tbody td:first-child { width: 30%; font-weight: 700; } 
    table tbody td:first-child { background: var(--table-header); } 
    
    .hint{font-size:12px;color:var(--muted)}
    .row .stack{display:flex;gap:8px;flex-wrap:wrap}
    .pill{padding:8px 12px;border:1px solid var(--border);border-radius:999px;background:#fff;cursor:pointer}
    .pill.active{background:var(--main-color);color:#fff;border-color:var(--main-color)}
    
    /* 🛠️ CBM 입력 칸 디자인 통일 (너비는 콤보박스와 동일하게 100%를 따름) */
    #cbmInput {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      outline: none;
      box-sizing: border-box; 
    }

      /* 커스텀 핀 공통 스타일 유지 */
      .pin-wrap{
        position:relative; width:26px; height:26px;
        filter:drop-shadow(0 1px 1px rgba(0,0,0,.35));
      }
      .pin-svg{ display:block; width:100%; height:100%; }
      .pin-label{ position:absolute; left:50%; top:-6px; transform:translateX(-50%); background:rgba(255,255,255,.85); border:1px solid #e5e7eb; border-radius:6px; padding:2px 6px; font-size:11px; white-space:nowrap; }
  </style>

  
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"/>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
</head>
<body>
  <h1>NOTION API HUB — 테스트</h1>

  <div class="card">
    <div class="row">
      <label>외교유무 (다중선택)</label>
      <div class="stack" id="rolesBox">
        <span class="pill" data-role="DIPLOMAT">DIPLOMAT</span>
        <span class="pill" data-role="NON-DIPLOMAT">NON-DIPLOMAT</span>
      </div>
    </div>

    <div class="row">
      <label>국가</label>
      <div class="combo" id="countryCombo">
        <input type="text" placeholder="국가를 입력/선택 (예: 미국, 중국)" autocomplete="off">
        <div class="list"></div>
      </div>
    </div>

    <div class="row region-map-row">
      <label>지역</label>
      <div class="combo" id="regionCombo">
        <input type="text" placeholder="지역을 입력/선택 (예: A지역, B지역)" autocomplete="off" disabled>
        <div class="list"></div>
        <button id="btnToggleMap" type="button">지도 열기</button> 
      </div>
      </div>
    
    <div id="mapWrap" style="display:none; margin:8px 0;">
      <div id="map" style="height:360px;border-radius:12px;"></div>
      <div class="muted" style="margin-top:6px">
        • 핀을 클릭하면 해당 지역이 자동 선택됩니다. • 상단 돋보기에서 위치 검색도 가능합니다.  
        • 리스트에 없는 지역을 입력한 경우, 최근접 등록 지역으로 자동 보정됩니다.
      </div>
    </div>

    <div class="row">
      <label>업체</label>
      <div class="combo" id="companyCombo">
        <input type="text" placeholder="업체를 입력/선택 (예: A업체, B업체)" autocomplete="off" disabled>
        <div class="list"></div>
      </div>
    </div>

    <div class="row">
      <label>컨테이너/콘솔</label>
      <div class="combo" id="typeCombo">
        <input type="text" placeholder="20FT / 40HC / CONSOLE" autocomplete="off" value="20FT">
        <div class="list"></div>
      </div>
    </div>

    <div class="row">
      <label>CBM</label>
      <input id="cbmInput" type="number" min="0" step="1" placeholder="예: 10 (미입력 시 MIN CBM 기준)"/>
    </div>

    <div class="row">
      <div></div>
      <div><button id="btnFetch">조회</button></div>
    </div>
  </div>

  <div class="card"> <div class="muted">응답</div> <pre id="jsonOut" class="muted" style="white-space:pre-wrap;word-break:break-word;"></pre> </div>

  <div class="card expanded">
    <div class="muted">표 (item 기준, 노션 순서 유지)</div>
    <div id="tableWrap" class="muted">조회 후 여기에 렌더링됩니다.</div>
  </div>
  
<script>
  // ─────────────────────────────────────────────────────────
  // 설정
  // ─────────────────────────────────────────────────────────
  // 같은 도메인에서 쓰면 '' 사용. 다른 도메인 테스트면 절대 URL 사용.
  const BASE = 'https://notion-api-hub.vercel.app';
  // MAP.JSON은 이 HTML과 같은 폴더에 두세요.
  // 형식:
  // {
  //   "미국": [
  //     { "name": "A지역", "lat": 37.5, "lng": -122.0 },
  //     { "name": "B지역", "lat": 34.0, "lng": -118.2 }
  //   ],
  //   "브라질": [
  //     { "name": "Brasilia, Brazil", "lat": -15.8267, "lng": -47.9218 }
  //   ]
  // }
  // name은 노션 "지역"과 동일한 텍스트 권장.

  // ─────────────────────────────────────────────────────────
  // 공통 UI: 다중선택(외교유무) / 콤보(입력+필터+선택)
  // ─────────────────────────────────────────────────────────
  const rolesBox = document.getElementById('rolesBox');
  rolesBox.addEventListener('click', (e) => {
    const pill = e.target.closest('.pill');
    if (!pill) return;
    pill.classList.toggle('active');
  });

  function makeCombo(el, items = []) {
    const input = el.querySelector('input');
    const list  = el.querySelector('.list');
    let data = [...items];
    let selected = null;

    function render(filter='') {
      const f = filter.trim().toLowerCase();
      list.innerHTML = '';
      const filtered = data.filter(x => x.toLowerCase().includes(f));
      // 숫자 자연 정렬 + 접두어 우선
      const sorted = filtered.sort((a, b) => {
        const an = Number(a), bn = Number(b);
        if (!isNaN(an) && !isNaN(bn)) return an - bn;
        const ap = a.toLowerCase().startsWith(f) ? 0 : 1;
        const bp = b.toLowerCase().startsWith(f) ? 0 : 1;
        if (ap !== bp) return ap - bp;
        return a.localeCompare(b, 'ko');
      });
      sorted.forEach(v => {
        const div = document.createElement('div');
        div.className = 'item';
        div.textContent = v;
        div.onclick = () => {
          selected = v;
          input.value = v;
          el.classList.remove('open');
          list.innerHTML = '';
          el.dispatchEvent(new CustomEvent('change', { detail: v }));
        };
        list.appendChild(div);
      });
    }

    function setItems(arr) {
      data = [...new Set(arr.filter(Boolean))];
      input.disabled = data.length === 0;
      input.value = '';
      selected = null;
      render('');
    }

    function getValue() {
      return selected || input.value.trim();
    }

    // 추가: 현재 목록/값 세터 (지도/자동보정에서 사용)
    function getItems() { return [...data]; }
    function setValue(v) {
      selected = v;
      input.value = v;
      el.dispatchEvent(new CustomEvent('change', { detail: v }));
    }

    input.addEventListener('focus', () => { el.classList.add('open'); render(input.value); });
    input.addEventListener('input', () => { el.classList.add('open'); render(input.value); });
    document.addEventListener('click', (e) => { if (!el.contains(e.target)) el.classList.remove('open'); });

    setItems(items);
    return { setItems, getItems, getValue, setValue, input, list, root: el };
  }

  const countryCombo = makeCombo(document.getElementById('countryCombo'));
  const regionCombo  = makeCombo(document.getElementById('regionCombo'));
  const companyCombo = makeCombo(document.getElementById('companyCombo'));
  const typeCombo    = makeCombo(document.getElementById('typeCombo'), ['20FT','40HC','CONSOLE']);

  // ── 커스텀 핀 아이콘(SVG) ───────────────────────────
  // color: 채움색, withLabel: 라벨 표시 여부, labelText: 라벨 내용
  function makeSvgPinIcon(color, withLabel=false, labelText="") {
    const svg = `
    <svg class="pin-svg" viewBox="0 0 24 24" aria-hidden="true">
      <path fill="${color}" d="M12 2C8.134 2 5 5.134 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.866-3.134-7-7-7zm0 9.5a2.5 2.5 0 1 1 0-5
        a2.5 2.5 0 0 1 0 5z"/>
    </svg>`;
    const labelHtml = withLabel
      ? `<div class="pin-label">${escapeHtml(labelText)}</div>`
      : "";
    const html = `<div class="pin-wrap">${svg}${labelHtml}</div>`;
    return L.divIcon({
      className: "",
      html,
      iconSize: [26, 26],
      iconAnchor: [13, 26] // 아래 중앙이 좌표를 정확히 가리키도록
    });
  }

  // ─────────────────────────────────────────────────────────
  // 지도 상태/유틸 (Leaflet + Geocoder + MAP.JSON)
  // ─────────────────────────────────────────────────────────
  let map, markerLayer, geocoder, mapInited = false;
  let mapData = null;           // 전체 MAP.JSON
  let countryMarkers = [];      // 현재 국가 마커 [{name,lat,lng,marker}]
  let __stickyNotice = null;    // 상단 고정 알림(배너) + 일회성 토스트 둘 다 지원

  function toast(msg, opts = {}) {
    const { sticky = false, timeout = 1500 } = opts;
  
    // sticky 모드: 클릭 전까지 유지되는 상단 배너
    if (sticky) {
      if (__stickyNotice) __stickyNotice.remove(); // 기존 배너 있으면 교체
      const el = document.createElement('div');
      el.innerHTML = `
        <div style="
          position: fixed; left: 50%; top: 16px; transform: translateX(-50%);
          background: rgba(17,17,17,.92); color: #fff; padding: 10px 14px;
          border-radius: 10px; border: 1px solid rgba(255,255,255,.15);
          box-shadow: 0 2px 8px rgba(0,0,0,.35);
          z-index: 10000; font-size: 13px; display:flex; align-items:center; gap:10px;
        ">
          <span>${msg}</span>
          <button id="__stickyClose" type="button" style="
            background:#fff; color:#111; border:0; border-radius:8px; padding:6px 10px; cursor:pointer;
          ">닫기</button>
        </div>
      `;
      el.querySelector('#__stickyClose').addEventListener('click', () => {
        el.remove(); __stickyNotice = null;
      });
      // 배너 자체 클릭으로 닫히게 하려면 다음 줄 주석 해제
      // el.firstElementChild.addEventListener('click', () => { el.remove(); __stickyNotice = null; });
  
      document.body.appendChild(el);
      __stickyNotice = el;
      return;
    }
  
    // 기본(일회성) 토스트
    const d = document.createElement('div');
    d.textContent = msg;
    d.style.cssText = `
      position: fixed; left: 50%; top: 24px; transform: translateX(-50%);
      background: rgba(0,0,0,.75); color: #fff; padding: 8px 12px; border-radius: 8px;
      z-index: 10000; font-size: 13px;
    `;
    document.body.appendChild(d);
    setTimeout(()=> d.remove(), timeout);
  }
  
  // 필요 시 외부에서 강제로 닫는 함수
  function hideStickyToast(){
    if (__stickyNotice) { __stickyNotice.remove(); __stickyNotice = null; }
  }

  // Haversine 거리(km)
  function haversineKm(aLat, aLng, bLat, bLng) {
    const R = 6371;
    const dLat = (bLat - aLat) * Math.PI/180;
    const dLng = (bLng - aLng) * Math.PI/180;
    const A = Math.sin(dLat/2)**2 +
              Math.cos(aLat*Math.PI/180)*Math.cos(bLat*Math.PI/180)*
              Math.sin(dLng/2)**2;
    return 2 * R * Math.asin(Math.sqrt(A));
  }

  function findNearest(lat, lng, points) {
    if (!points || !points.length) return null;
    let best = null, bestD = Infinity;
    for (const p of points) {
      const d = haversineKm(lat, lng, p.lat, p.lng);
      if (d < bestD) { best = p; bestD = d; }
    }
    return { point: best, distanceKm: bestD };
  }

async function ensureMapReady() {
  if (mapInited) return;
  mapInited = true;

  // 🔒 세계 한 장만 보이도록 경계 지정 (경도 ±180, 위도는 Web Mercator 유효 범위)
  const worldBounds = L.latLngBounds([[-85, -180], [85, 180]]);

  map = L.map('map', {
    center: [20, 0],
    zoom: 2,
    // 🔑 좌우 복제 월드(래핑) 방지 + 경계 밖으로 드래그 못 하게
    worldCopyJump: false,
    maxBounds: worldBounds,
    maxBoundsViscosity: 1.0    // 0~1 (1이면 경계에 찰싹 붙음)
  });

  // 🧭 타일도 래핑 금지 (noWrap) + 동일 경계 지정
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>',
    noWrap: true,
    bounds: worldBounds
  }).addTo(map);

  markerLayer = L.layerGroup().addTo(map);

  // (나머지 geocoder 설정/이벤트, MAP.JSON 로딩 등 기존 코드 계속)
  geocoder = L.Control.geocoder({ defaultMarkGeocode: false })
    .on('markgeocode', (e) => {
      const c = e.geocode.center;

      // 검색 핀: 라벨/팝업 없이 임시 마커
      const searchColor = getComputedStyle(document.documentElement).getPropertyValue('--pin-search').trim() || '#ef4444';
      const searchIcon  = makeSvgPinIcon(searchColor, false);
      const tmp = L.marker(c, { icon: searchIcon, keyboard:false, riseOnHover:true }).addTo(map);
      setTimeout(() => map.removeLayer(tmp), 4000);

      map.setView(c, 9);

      if (countryMarkers.length) {
        const hit = findNearest(c.lat, c.lng, countryMarkers);
        if (hit?.point) {
          regionCombo.setValue(hit.point.name);
          toast(`가장 가까운 등록 지역: ${hit.point.name} (~${hit.distanceKm.toFixed(1)}km)`, { sticky: true });
        }
      }
    })
    .addTo(map);

  // MAP.JSON 로드 (기존 그대로)
  try {
    const r = await fetch('./MAP.JSON', { cache: 'no-store' });
    mapData = await r.json();
  } catch (e) {
    console.warn('MAP.JSON 로드 실패:', e);
    mapData = {};
  }
}


  function setMapCountry(country) {
    if (!mapInited) return;
    markerLayer.clearLayers();
    countryMarkers = [];
    if (!mapData || !mapData[country]) return;

    const pts = mapData[country];
    const bounds = [];
    pts.forEach(p => {
      // CSS 변수에서 등록 핀 색을 읽어옴(없으면 기본 파랑)
      const regColor = getComputedStyle(document.documentElement).getPropertyValue('--pin-reg').trim() || '#2563eb';
      // 라벨을 표시하지 않으려면 두 번째 인자를 false로 유지
      const regIcon  = makeSvgPinIcon(regColor, false /*withLabel*/, /*labelText*/ "");
      
      // 라벨을 핀 위에 표시하고 싶다면 위 줄 대신:
      // const regIcon  = makeSvgPinIcon(regColor, true, p.name);
      
      const m = L.marker([p.lat, p.lng], { icon: regIcon })
        .addTo(markerLayer)
        .bindPopup(p.name);

      m.on('click', () => {
        regionCombo.setValue(p.name); // 핀 클릭 → 지역 세팅
        toast(`지역 선택: ${p.name}`);
      });
      countryMarkers.push({ ...p, marker: m });
      bounds.push([p.lat, p.lng]);
    });
    if (bounds.length) map.fitBounds(bounds, { padding:[20,20] });
  }

  // 지도 토글
  document.getElementById('btnToggleMap').addEventListener('click', async () => {
    const wrap = document.getElementById('mapWrap');
    const open = wrap.style.display !== 'none';
    if (open) {
      wrap.style.display = 'none';
      document.getElementById('btnToggleMap').textContent = '지도 열기';
    } else {
      wrap.style.display = 'block';
      await ensureMapReady();
      const c = countryCombo.getValue();
      if (c) setMapCountry(c);
      setTimeout(()=> map.invalidateSize(), 30);
      document.getElementById('btnToggleMap').textContent = '지도 닫기';
    }
  });

  // ─────────────────────────────────────────────────────────
  // 국가 → 지역 → 업체 로딩 (백엔드 API 연동)
  // ─────────────────────────────────────────────────────────
  countryCombo.root.addEventListener('change', async () => {
    const country = countryCombo.getValue();
    if (!country) return;
    try {
      const res = await fetch(`${BASE}/api/regions/${encodeURIComponent(country)}`);
      const j = await res.json();
      regionCombo.setItems(j.regions || []);
      companyCombo.setItems([]);
    } catch {
      regionCombo.setItems([]);
      companyCombo.setItems([]);
    }
    if (mapInited && document.getElementById('mapWrap').style.display !== 'none') {
      setMapCountry(country);
    }
  });

  regionCombo.root.addEventListener('change', async () => {
    const country = countryCombo.getValue();
    const region  = regionCombo.getValue();
    if (!country || !region) return;
    const mode = 'options'; // or 'data' (느림)
    try {
      const url = `${BASE}/api/companies/by-region?country=${encodeURIComponent(country)}&region=${encodeURIComponent(region)}&mode=${mode}`;
      const res = await fetch(url);
      const j = await res.json();
      companyCombo.setItems(j.companies || []);
    } catch {
      companyCombo.setItems([]);
    }
  });

  // 초기 국가 목록
  (async function init() {
    const dbg = await fetchDebug();
    const countries = dbg.countries || Object.keys(dbg.dbStructure || {});
    countryCombo.setItems(countries || []);
  })();

  async function fetchDebug() {
    const res = await fetch(`${BASE}/api/debug/config`);
    if (!res.ok) throw new Error('debug/config 오류');
    return await res.json();
  }

  // ─────────────────────────────────────────────────────────
  // 조회: 드롭다운에 없는 ‘자유 입력 지역’은 최근접 등록 지역으로 자동 보정 후 호출
  // ─────────────────────────────────────────────────────────
  document.getElementById('btnFetch').addEventListener('click', async () => {
    const country = countryCombo.getValue();
    let   region  = regionCombo.getValue();   // 사용자가 직접 입력 가능
    const company = companyCombo.getValue();
    const type    = typeCombo.getValue();
    const roles   = Array.from(rolesBox.querySelectorAll('.pill.active')).map(p=>p.dataset.role);
    const cbmVal  = parseInt(document.getElementById('cbmInput').value, 10);

    if (!country || !company) {
      alert('국가와 업체를 선택하세요.');
      return;
    }

    // (중요) 지역 자유입력 시 최근접 등록 지역으로 보정
    const list = regionCombo.getItems();
    if (region && !list.includes(region)) {
      try {
        await ensureMapReady();
        const pick = await geocodeNearest(region, country);
        if (pick) {
          toast(`입력한 지역이 없어 가장 가까운 등록 지역(${pick.name})으로 대체합니다 (~${pick.distKm.toFixed(1)}km)`);
          region = pick.name;
          regionCombo.setValue(region);
        }
      } catch (e) {
        console.warn('최근접 보정 실패:', e);
      }
    }

    const params = new URLSearchParams();
    params.set('company', company);
    params.set('type', type);
    if (region) params.set('region', region);
    if (roles.length) params.set('roles', roles.join(','));
    if (Number.isFinite(cbmVal)) params.set('cbm', String(cbmVal)); // CONSOLE/보정 계산용

    const url = `${BASE}/api/costs/${encodeURIComponent(country)}?${params.toString()}`;
    try {
      const res = await fetch(url);
      const j = await res.json();
      document.getElementById('jsonOut').textContent = JSON.stringify(j, null, 2);
      renderTable(j, type, Boolean(region));
    } catch (e) {
      document.getElementById('jsonOut').textContent = String(e);
      document.getElementById('tableWrap').innerHTML = '<div class="muted">오류로 표를 표시할 수 없습니다.</div>';
    }
  });

  // Geocoder를 Promise로 감싸 최근접 등록 지역 찾기
  async function geocodeNearest(query, country) {
    if (!mapData || !mapData[country]?.length) return null;
    const pts = mapData[country];

    const center = await new Promise((resolve, reject) => {
      if (!geocoder || !geocoder.options?.geocoder) return resolve(null);
      geocoder.options.geocoder.geocode(query, (results) => {
        if (results && results[0]) resolve(results[0].center);
        else resolve(null);
      });
      // 타임아웃(2.5s)
      setTimeout(()=> resolve(null), 2500);
    });

    if (!center) return null;
    const hit = findNearest(center.lat, center.lng, pts);
    if (!hit?.point) return null;
    return { name: hit.point.name, distKm: hit.distanceKm };
  }

  // ─────────────────────────────────────────────────────────
  // 표 렌더링 (rows 순서 그대로, 추가내용은 HTML 그대로)
  // ─────────────────────────────────────────────────────────
  function renderTable(data, type, hasRegionFilter) {
    const wrap = document.getElementById('tableWrap');
    if (!data || data.ok === false) {
      wrap.innerHTML = '<div class="muted">응답이 비어있거나 오류입니다.</div>';
      return;
    }
    const rows = data.rows || [];
    if (rows.length === 0) {
      wrap.innerHTML = '<div class="muted">데이터가 없습니다.</div>';
      return;
    }

    if (hasRegionFilter) {
      let html = `<table><thead><tr><th>항목</th><th>${type}</th><th>추가내용</th></tr></thead><tbody>`;
      for (const row of rows) {
        html += `<tr>
          <td>${escapeHtml(row.item)}</td>
          <td>${fmt(row[type])}</td>
          <td>${row.extra ?? ''}</td>
        </tr>`;
      }
      html += `</tbody></table>`;
      wrap.innerHTML = html;
    } else {
      const grouped = {};
      for (const r of rows) {
        const reg = r.region || '기타';
        if (!grouped[reg]) grouped[reg] = [];
        grouped[reg].push(r);
      }
      let html = '';
      for (const reg of Object.keys(grouped)) {
        html += `<h3 style="margin-top:18px">${escapeHtml(reg)} (${type})</h3>`;
        html += `<table><thead><tr><th>항목</th><th>${type}</th><th>추가내용</th></tr></thead><tbody>`;
        for (const row of grouped[reg]) {
          html += `<tr>
            <td>${escapeHtml(row.item)}</td>
            <td>${fmt(row[type])}</td>
            <td>${row.extra ?? ''}</td>
          </tr>`;
        }
        html += `</tbody></table>`;
      }
      wrap.innerHTML = html;
    }
  }

  function fmt(v){ return (v===null||v===undefined) ? '' : v; }
  function escapeHtml(s){
    return String(s)
      .replace(/[&<>"']/g,(m)=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))
      .replace(/\n/g,'<br>');
  }
</script>
</body>
</html>

